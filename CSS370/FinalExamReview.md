# Use case
- Scenario-oriented description of expected functionality for the system 
  - Show “what” can be done (instead of “how” it works
  - Don’t care about class, object, package, etc. 
  - Triggered by an actor
  - UML syntax
    - Actor: anything external to the program that interacts with the program
    - Use case: Provides value to actors
    - Interaction
    - Relationship between use cases: include, extend, inheritance
    - Relationship between actors: inheritance

![Actor][./Actor.png]

# Diagram comparisons
Diagram Type | Data | Proc. | Static | Dynamic | Integration | Level Of Disclousure | Scope
--- | --- | --- | --- | --- | --- | --- | ---
Domain | x |   | x |   |   | low | system
Use case |   |   |   |   | x | low | system
Activity |   | x |   | x |   | med | UC
Robustness | x | x |   | x | x | high | UC
Sequence | x | x |   | x | x | high | UC
Data Flow | x |   |   | x |   | low | system

# Use Case Description
- Required: use case name, scenarious, alternatives
- Optional: purpose/objective, actors, preconditoins, postconditions, system behavior
- Always have actor and action

# Data Flow Diagrams
- Not UML
- Shows how a system’s entities (external), processes, and storages (internal) are 
interconnected 
- Syntax
  - Entity (People, roles, organizations, external systems, etc.)
  - Data flow (input, output)
  - Process
  - Storage (Databases, files, folders, etc.)
- Leveled
  - Level 0 (Context diagram) - system level (only one process, no storage)
  - Level 1
  - Level 2
  - etc.
- Rules
  - No direct link between nouns (entity, storage)
  - Storage introduced at level 1+ (not at context)
  - Process
    - No black hole (all in, no out)
    - no white hole (no in, all out)
    - Add numbers to procesess for tracking across levels (in the same level, no order)

# Robustness Analysis / Diagram
- Purposes
  - Identify objects (view, entities) needed to implement the use case
  - Identify processes (controllers) needed to implemnt the use case
- Objects
  - Actors
  - View/Interface objects
    - What various actors use to interact with the system
    - e.g. pages, dialog boxes
  - Model/Entity objects
    - Both temporary and persistent data that are used/generated by the system
    - e.g. temporary data structures, database tables, etc.
  - Processes/Controller object
    - To state loosely the ones that facilitate interactions between the above
- Construction
  - One diagram for each use case
  - Created sentence-by-sentence from the text of the use case
- Rules
  - Actors can only talk to boundary objects
    - Users can only deal with View objects
  - Boundary objects can only talk to controllers and actors.
    - Views only talk with Users and controllers
  - Entity objects can only talk to controllers.
    - Model objects can only talk with controllers
  - Controllers can talk to boundary objects, entity objects, and other controllers, but not to actors
    - Controllers are always middleware and so don’t to anything outside the system

# Sequence diagram
- Purpose
  - Help assign operations to classes/instances while drawing messages
  - Drive the detaield design - sequencing of assigned calls
  - Further refine set of required classess and operatrions needed
- How
  - One sequence diagram per use case
  - Both basic and alternate courses
  - Focus on behavior allocation

# Class Design
- class identification from project spec/requirements
  - nouns are classes/objects/fields
  - verbs are potential methods or responsibilites of a class
- CRC card exercises
  - write class name on index card
  - next to each class, list the following
    - responsibilities: problems to be solved (verb phrases)
    - collaborators: other classes that are sent messages by this class (asymmetric)

# Class Diagrams
- Definition
  - a picture of the classes in a OO system, their fields and methods, and connections between the classes that interact or inherit from each other
  - does not represent
    - details of the class interaction
    - algorithmic details (behavior implementation)
- Syntax
  - Class name on top of box
    - \<\<interface\>\> above interface name
    - abstract class in italics
  - attributes (optional)
    - all fields of object
    - (-) private
    - (+) public
    - (/) protected
  - operation/methods (optional)
    - may omit trivial methods (except from interface)
    - should not include inherited methods
  - relationship between classses
    - generalization (inheritance betwen classes / interface implementaion)
    - association (dependency/aggregation/composition)
    - may include multiplicity
